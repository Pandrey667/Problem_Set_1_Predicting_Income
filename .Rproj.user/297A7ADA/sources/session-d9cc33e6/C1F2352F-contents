### Limpiamos el ambiente de RStudio
remove(list = ls())

### Librerías usadas en el trabajo
library(rvest)         ## Web-scrapping con R
library(tidyverse)     ## Manipulación de datos
library(purrr)         ## Loop para unificar el web-scrapping
library(moments)       ## Cálculo del coeficiente de asimetría y la Kurtosis
library(modelsummary)  ## Tablas de salida en formato LaTeX
library(ggplot2)       ## Gramática de gráficos
library(gridExtra)     ## Matriz de gráficas en ggplot2
library(viridis)       ## Paleta de colores para gráficas

### URL de la página de GitHub del doctor Ignacio Sarmiento
url_base <- "https://ignaciomsarmiento.github.io/GEIH2018_sample/pages/"

### Generamos las URLs de las páginas (del 1 al 10 por ejemplo)
paginas <- paste0(url_base, "geih_page_", 1:10, ".html")

### Función para extraer tablas en formato HTML de las páginas web 
extraer_tabla <- function(url_tabla){
  ## Leemos la página en formato HTML
  pagina <- read_html(url_tabla)
  ## Ubicamos los nodos que contienen las tablas HTML
  nodo_tabla <- pagina %>% 
    html_node("table")
  ## Extraémos las tablas ubicadas en la página escrapeada
  tabla <- nodo_tabla %>% 
    html_table(fill = TRUE)
  
  ## Renombramos las columnas sin título con rl caracter col_1
  names(tabla) <- if_else(
    is.na(names(tabla)) | names(tabla) == "",
    paste0("col_", seq_along(tabla)),
    names(tabla)
  )
  
  ## Convertimos la tabla con la entrada de la función (url_tabla)
  tabla %>% mutate(origen = url_tabla)
}

### Aplicamos el loop map, del paquete purrr, a las 10 páginas web con las tablas  
data_final <- map_dfr(paginas, extraer_tabla)

### Estudiamos la clase del objeto data_final
class(data_final)

### Estudiamos las columnas del data frame 
glimpse(data_final)

### Filtramos, con la librería Tidyverse, data_final
### Personas estrictamente mayores de 18 años
### Personas ocupadas (ocu =1)

df_1 <- data_final %>% 
  filter(age >= 18 & ocu %in% 1)


### Obtención de la variable salario por hora para cada individuo
df_2 <- df_1 %>% 
  ## Filtramos para obtener solo individuos tienen horas trabajadas
  filter(totalHoursWorked != 0) %>% 
  mutate(
    ## Creamos la variable ingreso_total que está compuesta por la sumatoria
    ## de impaes + isaes. Es decir: ingresos del trabajo principal + ingresos de un posible trabajo adicional
    ingreso_total = ifelse(!is.na(impa), impa, impaes) +
      ifelse(!is.na(isa),  isa,  isaes),
    ## Obtenemos el total de horas trabajadas al mes (multiplicamos totalHoursWorked x 4)
    horas_mes_Worked = totalHoursWorked * 4,
    ## El salario por hora (salario_hora) es la división del ingreso total sobre las horas trabajas al mes (obtenidas con anterioridad) 
    salario_hora = ingreso_total / horas_mes_Worked
  )

#################### Gráficos de las variables empleadas en las regresiones #############################################


### Filtramos los NA y valores iguales a cero en 
df_2 <- df_2 %>% 
  filter(!is.na(salario_hora)) %>% 
  filter(salario_hora != 0) %>% 
  filter(!is.na(maxEducLevel))

### Creamos la variable del logaritmo natural del salario por hora
df_2$ln_wage <- log(df_2$salario_hora)

### Convertimos df_2 a un objeto data frame
df_2 <- as.data.frame(df_2)


### Construímos el data frame variables_num con las variables numéricas
variables_num <- df_2 %>% 
  select(salario_hora, 
         ln_wage, age, 
         totalHoursWorked)

### Tabla de estadísticas básicas (sin asimetría y curtosis)
descr <- datasummary_skim(variables_num, 
                          type = "numeric", 
                          output = "data.frame") %>%
  select(-`Histogram`)

### Rebombramos la primera columna de la tabla descr como Variable
colnames(descr)[1] <- "Variable"

### Calculamos el número de observaciones (N)
n_obs <- sapply(variables_num, function(x) sum(!is.na(x)))

### Eliminar columna Unique y reordenamos para que N sea la primera columna
descr <- descr %>%
  select(-Unique) %>%
  mutate(N = n_obs[match(Variable, names(n_obs))]) %>%
  relocate(N, .after = Variable)

### Calculamos el coeficiente de asimetría y la curtosis
extra <- data.frame(
  Variable  = names(variables_num),
  Asimetría = apply(variables_num, 2, skewness, na.rm = TRUE),
  Curtosis  = apply(variables_num, 2, kurtosis, na.rm = TRUE)
)

### Unimos las tablas que contienen las medidas de tendencia central y las de forma
final <- merge(descr, extra, by = "Variable")

# Exportamos la tabla de las variables numéricas en formato LaTeX 
datasummary_df(final,
               output = "latex",
               title = "Estadísticas descriptivas con asimetría y curtosis")

### Recategorizamos la variable dicotómica de género (0 )
df_2$sex <- factor(df_2$sex, 
                   levels = c(0, 1), 
                   labels = c('Hombre', 
                              'Mujer'))

### Recategorizamos la variable dicotómica de trabajo formal
df_2$formal <- factor(df_2$formal, 
                      levels = c(0, 1), 
                      labels = c('informal', 
                                 'formal'))

### Recategorizamos la variable de niveles educativos
df_2$maxEducLevel <- factor(
  df_2$maxEducLevel,
  levels = c(1, 2, 3, 4, 5, 6, 7),
  labels = c("Ninguno",
             "Preescolar",
             "Básica primaria (1º - 5º)",
             "Básica secundaria (6º - 9º)",
             "Media (10º - 13º)",
             "Superior o universitaria",
             "No sabe, no informa"))


### Recategorizamos la variable de estratos socieconómicos
df_2$estrato1 <- factor(df_2$estrato1,
                        levels = 1:6,
                        labels = c("Estrato 1","Estrato 2","Estrato 3",
                                   "Estrato 4","Estrato 5","Estrato 6"))


### Función para calcular la moda
get_mode <- function(x) {
  ux <- na.omit(unique(x))
  ux[which.max(tabulate(match(x, ux)))]
}

### Calculamos N, Moda, frecuencia y proporción de la moda 
cat_summary <- df_2 %>%
  select(sex, formal, maxEducLevel, estrato1) %>%
  summarise(across(
    everything(),
    list(
      ## Tamaño muestral de las variables
      N = ~sum(!is.na(.x)),
      ## Número de categorías por cada variable
      Categories = ~length(unique(na.omit(.x))),
      ## Moda de cada variable estudiada
      Moda = ~get_mode(.x),
      ## Frecuencia de la moda
      FreqModa = ~max(table(.x, useNA = "no")),
      ## Porporción de la moda
      PropModa = ~max(prop.table(table(.x, useNA = "no")))
    ),
    .names = "{.col}_{.fn}"
  )) %>%
  pivot_longer(
    cols = everything(),
    names_to = c("Variable", ".value"),
    names_sep = "_"
  )


### Exportamos la tabla de las variables categóricas en formato LaTeX
datasummary_df(cat_summary,
               output = "latex",
               title = "Estadísticas descriptivas de variables categóricas")


########################## Gráficas de las variables ########################################################################################################

#### Histograma del salario por hora
test_1 <- df_2 %>% 
  ggplot(., aes(x = salario_hora)) + 
  geom_histogram(bins = 15, 
                 fill = "darkgoldenrod1", 
                 color = "black") + 
  ylab('Frecuencia') + 
  xlab('Salario por hora (Pesos colombianos)') + 
  ggtitle('Salarios por hora') + 
  theme(plot.title = element_text(hjust = 0.5, 
                                  size = 17), 
        plot.caption = element_text(hjust = 0))
#labs(caption = "Fuente: Gran Encuesta Integrada de Hogares (GEIH) 2018. Gráfica de elaboración propia.")


#### Histograma del logaritmo natural del salario por hora
test_2 <- df_2 %>%
  ggplot(., aes(x = ln_wage)) + 
  geom_histogram(bins = 15, 
                 fill = "darkgoldenrod1", 
                 color = "black") + 
  ylab('Frecuencia') + 
  xlab('Escala logarítmica') + 
  ggtitle('Logaritmo natural del Salario por hora') + 
  theme(plot.title = element_text(hjust = 0.5, 
                                  size = 17), 
        plot.caption = element_text(hjust = 0))
#labs(caption = "Fuente: Gran Encuesta Integrada de Hogares (GEIH) 2018")

### Matriz de gráficos del salario por hora
salarios_graph <- grid.arrange(test_1, test_2, ncol = 2)

### Exportamos la matriz de gráficos del salario
ggsave('salarios.jpeg', plot = salarios_graph, 
       width = 10, height = 6, dpi = 300)



### Diagrama de barras de la edad de las personas encuestadas
test_3 <- df_2 %>% 
  ggplot(aes(x = age)) + 
  geom_histogram(binwidth = 2, 
                 fill = "#00B2EE", 
                 color = "black") +
  ylab("Frecuencia") + 
  xlab("Edad (años)") + 
  ggtitle("Edad de las personas encuestadas") + 
  scale_x_continuous(breaks = seq(18, 91, 3)) +
  theme(plot.title = element_text(hjust = 0.5, size = 17),
        plot.caption = element_text(hjust = 0))
#labs(caption = "Fuente: Gran Encuesta Integrada de Hogares (GEIH) 2018. Gráfica de elaboración propia.")


estratos_perc %>% 
  ggplot(., aes(x = estrato1, 
                y = n)) + 
  geom_col(stat = "count", 
           fill = "firebrick", 
           color = "black") + 
  geom_text(aes(label = scales::label_percent(accuracy = 0.1)(percentage)),
            vjust = -0.5, size = 6) +
  ylab('Frecuencia') + 
  xlab('Estratos socioeconómicos') + 
  scale_y_continuous(breaks = seq(0, 6500, 1000)) + 
  ggtitle('Porcentaje de estratos en la GEIH 2018') + 
  theme(plot.title = element_text(hjust = 0.5, 
                                  size = 17), 
        plot.caption = element_text(hjust = 0), 
        axis.text.x = element_text(size = 12), 
        axis.text.y = element_text(size = 11)) +
  labs(caption = "Fuente: Gran Encuesta Integrada de Hogares (GEIH) 2018. Gráfica de elaboración propia.")




test_4 <- df_2 %>% 
  ggplot(., aes(x = totalHoursWorked )) + 
  geom_bar(stat = "bin", 
           fill = "royalblue", 
           color = "black") +
  ylab('Frecuencia') + 
  xlab('Horas trabajadas') + 
  scale_x_continuous(breaks = seq(0, 130, 10)) + 
  scale_y_continuous(breaks = seq(0, 10000, 2000)) + 
  ggtitle('Horas de trabajo semanal') + 
  theme(plot.title = element_text(hjust = 0.5, 
                                  size = 17), 
        plot.caption = element_text(hjust = 0)) 
#labs(caption = "Fuente: Gran Encuesta Integrada de Hogares (GEIH) 2018. Gráfica de elaboración propia.")

### Matriz de gráficos del salario por hora
independ_graph1 <- grid.arrange(test_3, test_4, ncol = 2)

### Exportamos la matriz de gráficos del salario
ggsave('independientes_1.jpeg', plot = independ_graph1, 
       width = 10, height = 6, dpi = 300)


### Generamos una tabla de frecuencia añadiendo los porcentajes de cada categoría
genero <- df_2 %>% 
  group_by(sex) %>% 
  summarize(freq = n()) %>% 
  mutate(Pct = round(freq / sum(freq), 2))


### Diagrama de barras con la variable sex de la GEIH
cat_graph_1 <- genero %>% 
  ggplot(aes(x = factor(sex), 
             y = freq, 
             fill = factor(sex))) +
  geom_col(color = "black") + 
  geom_text(aes(label = scales::label_percent(accuracy = 0.1)(Pct)),
            vjust = -0.5, size = 6) +
  xlab("Sexo") +  ylab("Frecuencia") + 
  ggtitle("Distribución por sexo") +
  scale_fill_manual(values = c("dodgerblue1", "firebrick2"),
                    labels = c("Mujer", "Hombre")) +
  theme(plot.title = element_text(hjust = 0.5, 
                                  size = 17), 
        legend.title = element_blank(), 
        axis.text.x = element_text(size = 14), 
        axis.title.x = element_text(size = 15), 
        axis.title.y = element_text(size = 15), 
        legend.text = element_text(size = 12))


### Recategorizamos la variable de nivel máximo alcanzado
df_2$maxEducLevel <- factor(
  df_2$maxEducLevel,
  levels = c(1, 2, 3, 4, 5, 6, 7),
  labels = c("Ninguno",
             "Preescolar",
             "Básica primaria (1º - 5º)",
             "Básica secundaria (6º - 9º)",
             "Media (10º - 13º)",
             "Superior o universitaria",
             "No sabe, no informa"))

### Eliminamos el único dato atípico que hay en la variable del nivel educativo
df_2 <- df_2 %>% 
  filter(!is.na(maxEducLevel))

### Creamos un data frame con el porcentaje de las categorías del nivel educativo
nivel_educ <- df_2 %>%
  count(maxEducLevel) %>%
  mutate(percentage = n / sum(n))


### Diagrama de barras para el máximo nivel educativo alcanzado por los individuos
cat_graph_2 <- nivel_educ %>% 
  ggplot(aes(x = maxEducLevel, 
             y = n, 
             fill = maxEducLevel)) + 
  geom_col(color = "black") + 
  geom_text(aes(label = scales::label_percent(accuracy = 0.1)(percentage)),
            vjust = -0.5, size = 6) +
  ylab("Frecuencia") + 
  xlab("Nivel educativo") + 
  scale_y_continuous(breaks = seq(0, 8000, 1000)) + 
  scale_fill_viridis(discrete = TRUE, option = "D") + 
  ggtitle("Máximo nivel educativo\nalcanzado por los individuos") + 
  theme(plot.title = element_text(hjust = 0.5, size = 17), 
        plot.caption = element_text(hjust = 0), 
        axis.text.x = element_text(size = 12, angle = 20, hjust = 1), 
        axis.text.y = element_text(size = 11))

### Guardamos las gráficas del sexo y del nivel educativo en una matriz de gráficos
independ_graph2 <- grid.arrange(cat_graph_1, 
                                cat_graph_2, 
                                ncol = 2)

### Exportamos la matriz de gráficos del salario
ggsave('independientes_2.jpeg', plot = independ_graph2, 
       width = 15, height = 8, dpi = 300)